package bridge

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/lyraproj/issue/issue"

	"github.com/hashicorp/terraform/helper/validation"

	"github.com/hashicorp/terraform/helper/schema"
)

type generator struct {
	generated     map[string]bool
	Namespace     string
	Package       string
	ResourceTypes []structData
	StructTypes   []structData
	IncludeTime   bool
	IncludeRegexp bool
	skipPrefix    string
}

type structData struct {
	StructType          string
	NativeType          string
	IdName              string
	ProvidedAttributes  []string
	ImmutableAttributes []string
	StructFields        []structField
}

type structField struct {
	FieldName string
	FieldType string
}

const codeTemplate = `// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-Provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package {{.Package}}

import (
{{- if .IncludeRegexp}} "regexp"{{end}}
{{- if .IncludeTime}} "time"{{end}}
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/lyraproj/lyra/pkg/bridge"
	"github.com/lyraproj/pcore/px"
	"github.com/lyraproj/servicesdk/service"
)

type (
{{- range .ResourceTypes}}
	{{.StructType}} struct {
		{{.IdName}} *string ` + "`" + `lyra:"ignore"` + "`" + `
  {{- range .StructFields}}
    {{.FieldName}} {{.FieldType}}{{end}}
	}
{{end}}

{{- range .StructTypes}}
	{{.StructType}} struct {
  {{- range .StructFields}}
    {{.FieldName}} {{.FieldType}}{{end}}
	}
{{end}})

func Initialize(sb *service.Builder, p *schema.Provider) {
  // Generic handler API
  sb.RegisterAPI("{{$.Namespace}}::GenericHandler", bridge.NewTFHandler(nil, "", nil))

  // Registration of resource types with handler
	var rt px.Type
{{- range .ResourceTypes}}
	rt = sb.RegisterTypes("{{$.Namespace}}",
	{{- if or .ProvidedAttributes .ImmutableAttributes}} sb.BuildResource(&{{.StructType}}{}, func (b service.ResourceTypeBuilder) {
	{{- if .ProvidedAttributes}}
		b.ProvidedAttributes({{range $i, $e := .ProvidedAttributes}}{{if $i}}, {{end}}"{{$e}}"{{end}})
	{{- end}}
	{{- if .ImmutableAttributes}}
		b.ImmutableAttributes({{range $i, $e := .ImmutableAttributes}}{{if $i}}, {{end}}"{{$e}}"{{end}})
	{{- end}}
	})
	{{- else}} &{{.StructType}}{}
	{{- end}})[0]
	sb.RegisterHandler("{{$.Namespace}}::{{.StructType}}Handler", bridge.NewTFHandler(p,	"{{.NativeType}}", rt), rt)
{{end}}
{{- if .StructTypes}}
  // Registration of non-resource types
	sb.RegisterTypes("{{$.Namespace}}"{{range .StructTypes}},
    &{{.StructType}}{}{{end}})
{{- end}}
}
`

func mkdirs(filename string) {
	dirName := filepath.Dir(filename)
	if _, serr := os.Stat(dirName); serr != nil {
		merr := os.MkdirAll(dirName, os.ModePerm)
		if merr != nil {
			panic(merr)
		}
	}
}

func (g *generator) deriveGoType(goType, name string) string {
	// Using a double underscore between type and field name ensures uniqueness of derived type name
	return fmt.Sprintf("%s__%s", goType, name)
}

func isValidateFunc(actual, expected schema.SchemaValidateFunc) bool {
	return reflect.ValueOf(actual).Pointer() == reflect.ValueOf(expected).Pointer()
}

func (g *generator) getGoType(goType, name string, s *schema.Schema) string {
	//   TypeBool - bool
	//   TypeInt - int64
	//   TypeFloat - float64
	//   TypeString - string, time.Time, or regexp.Regexp
	//   TypeList - []<type of Elem>
	//   TypeMap - map[string]<type of Elem>
	//   TypeSet - []<type of Elem>
	var t string
	switch s.Type {
	case schema.TypeBool:
		t = "bool"
	case schema.TypeInt:
		t = "int64"
	case schema.TypeFloat:
		t = "float64"
	case schema.TypeString:
		t = "string"
		if s.ValidateFunc != nil {
			if isValidateFunc(s.ValidateFunc, validation.ValidateRFC3339TimeString) {
				g.IncludeTime = true
				t = "time.Time"
			} else if isValidateFunc(s.ValidateFunc, validation.ValidateRegexp) {
				g.IncludeRegexp = true
				t = "regexp.Regexp"
			}
		}
	case schema.TypeList:
		t = "[]" + g.getElemType(goType, name, s)
	case schema.TypeMap:
		t = "map[string]" + g.getElemType(goType, name, s)
	case schema.TypeSet:
		t = "[]" + g.getElemType(goType, name, s)
	default:
		panic(fmt.Sprintf("Unknown schema type: %v", s.Type))
	}
	return g.skipPackage(t)
}

func (g *generator) skipPackage(name string) string {
	if strings.HasPrefix(name, g.skipPrefix) {
		name = name[len(g.skipPrefix):]
	}
	return name
}

func (g *generator) getElemType(goType, name string, s *schema.Schema) string {
	var t string
	switch el := s.Elem.(type) {
	case nil:
		t = "string"
	case *schema.Resource:
		t = g.deriveGoType(goType, name)
		g.generateResourceType(t, el, false)
	case *schema.Schema:
		t = g.getGoType(goType, name, el)
	case schema.ValueType:
		switch el {
		case schema.TypeBool:
			t = "bool"
		case schema.TypeInt:
			t = "int64"
		case schema.TypeFloat:
			t = "float64"
		case schema.TypeList:
			t = "[]string"
		case schema.TypeMap:
			t = "map[string]string"
		case schema.TypeSet:
			t = "[]string"
		default:
			t = "string"
		}
	default:
		panic(fmt.Sprintf("Unsupported TypeMap: %v", el))
	}
	return t
}

func (g *generator) getGoTypeWithPtr(goType, name string, s *schema.Schema) string {
	t := g.getGoType(goType, name, s)
	if !s.Required {
		t = "*" + t
	}
	return t
}

func (g *generator) generateCode() []byte {
	tmpl := template.Must(template.New("codeTemplate").Parse(codeTemplate))
	b := bytes.NewBuffer(make([]byte, 0, 0x10000)) // Start with a reasonably large buffer to avoid lots of reallocation
	err := tmpl.Execute(b, g)
	if err != nil {
		panic(err)
	}
	return b.Bytes()
}

func (g *generator) generateResourceType(nativeType string, r *schema.Resource, topLevel bool) {
	if g.generated[nativeType] {
		return
	}
	g.generated[nativeType] = true

	structType := strings.Title(g.skipPackage(nativeType))
	var idName string
	if topLevel {
		// Append 'ID' rather than '_id' to ensure that there's no collision with TF properties
		idName = structType + `ID`
	}

	// Sort field names to give predictable code generation
	names := make([]string, 0, len(r.Schema))
	for name := range r.Schema {
		names = append(names, name)
	}
	sort.Strings(names)

	// Check for provided and immutable attributes
	var providedAttributes []string
	var immutableAttributes []string

	if topLevel {
		providedAttributes = append(providedAttributes, issue.FirstToLower(idName))
	}
	for _, name := range names {
		s := r.Schema[name]
		if s.ForceNew {
			immutableAttributes = append(immutableAttributes, name)
		}
		if s.Computed {
			providedAttributes = append(providedAttributes, name)
		}
	}

	// Determine field names and types
	structFields := make([]structField, len(names))
	for i, name := range names {
		structFields[i] = structField{
			FieldName: strings.Title(name),
			FieldType: g.getGoTypeWithPtr(structType, name, r.Schema[name]),
		}
	}

	// Build template data
	sd := structData{
		IdName:              idName,
		StructType:          structType,
		NativeType:          nativeType,
		StructFields:        structFields,
		ProvidedAttributes:  providedAttributes,
		ImmutableAttributes: immutableAttributes}
	if topLevel {
		g.ResourceTypes = append(g.ResourceTypes, sd)
	} else {
		g.StructTypes = append(g.StructTypes, sd)
	}
}

// formatCode reformats the code as `go fmt` would
func (g *generator) formatCode(code []byte) []byte {
	fmt.Println(string(code))
	src, err := format.Source(code)
	if err != nil {
		panic(fmt.Errorf("unexpected error running format.Source: %s", err.Error()))
	}
	return src
}

func writeSourceFile(filename string, source ...[]byte) {
	mkdirs(filename)
	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	for _, s := range source {
		_, err = f.Write(s)
		if err != nil {
			panic(err)
		}
	}
}

// Generate the Lyra boilerplate needed to bridge to a Terraform provider
func Generate(p *schema.Provider, ns, pkg, filename string) {
	// Sort native types to give predictable output
	nativeTypes := make([]string, 0, len(p.ResourcesMap))
	for nativeType := range p.ResourcesMap {
		nativeTypes = append(nativeTypes, nativeType)
	}
	sort.Strings(nativeTypes)

	g := &generator{
		Namespace:     ns,
		Package:       pkg,
		ResourceTypes: make([]structData, 0, len(nativeTypes)),
		StructTypes:   make([]structData, 0),
		generated:     make(map[string]bool, 53),
		skipPrefix:    pkg + `_`,
	}

	// Generate code
	for _, nativeType := range nativeTypes {
		g.generateResourceType(nativeType, p.ResourcesMap[nativeType], true)
	}
	code := g.generateCode()

	// Write source
	writeSourceFile(filename, g.formatCode(code))
}
