package bridge

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform/helper/schema"
)

type generator struct {
	saltValue int
	code *bytes.Buffer
}

type prefixData struct {
	Namespace   string
	StructTypes []providerData
}

type providerData struct {
	StructType          string
	NativeType          string
	ProvidedAttributes  []string
	ImmutableAttributes []string
}

type structData struct {
	StructType   string
	StructFields []structField
	InsertID     bool
}

type structField struct {
	FieldName string
	FieldType string
}

const prefixTemplate = `// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-Provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/lyraproj/lyra/pkg/bridge"
	"github.com/lyraproj/pcore/px"
	"github.com/lyraproj/servicesdk/service"
)

func Initialize(sb *service.Builder, p *schema.Provider) {
	var evs []px.Type
  sb.RegisterAPI("{{$.Namespace}}::GenericHandler", bridge.NewTFHandler(nil, "", nil))
{{range .StructTypes}}
	evs = sb.RegisterTypes("{{$.Namespace}}", sb.BuildResource(&{{.StructType}}{}, func (b service.ResourceTypeBuilder) {
{{- if .ProvidedAttributes}}
	b.ProvidedAttributes({{range $i, $e := .ProvidedAttributes}}{{if $i}}, {{end}}"{{$e}}"{{end}}){{end}}
{{- if .ImmutableAttributes}}
	b.ImmutableAttributes({{range $i, $e := .ImmutableAttributes}}{{if $i}}, {{end}}"{{$e}}"{{end}}){{end}}
}))
	sb.RegisterHandler("{{$.Namespace}}::{{.StructType}}Handler", bridge.NewTFHandler(p,	"{{.NativeType}}", evs[0]), evs[0])
{{end}}
}
`

const typeTemplate = `
type {{.StructType}} struct {
{{if .InsertID}}
	{{.StructType}}_id *string ` + "`" + `lyra:"ignore"` + "`" + `{{end}}
{{range .StructFields}}
    {{.FieldName}} {{.FieldType}}
{{end}}
}
`

func mkdirs(filename string) {
	dirName := filepath.Dir(filename)
	if _, serr := os.Stat(dirName); serr != nil {
		merr := os.MkdirAll(dirName, os.ModePerm)
		if merr != nil {
			panic(merr)
		}
	}
}

func (g *generator) deriveGoType(goType, name string) string {
	g.saltValue++
	return fmt.Sprintf("%s_%s_%d", goType, name, g.saltValue)
}

func (g *generator) getGoType(goType, name string, s *schema.Schema) string {
	//   TypeBool - bool
	//   TypeInt - int
	//   TypeFloat - float64
	//   TypeString - string
	//   TypeList - []interface{}
	//   TypeMap - map[string]interface{}
	//   TypeSet - *schema.Set
	var t string
	switch s.Type {
	case schema.TypeBool:
		t = "bool"
	case schema.TypeInt:
		t = "int"
	case schema.TypeFloat:
		t = "float64"
	case schema.TypeString:
		t = "string"
	case schema.TypeList:
		switch s.Elem.(type) {
		case *schema.Resource:
			t = g.deriveGoType(goType, name)
			g.generateResourceType(t, s.Elem.(*schema.Resource), false)
			t = "[]" + t
		case *schema.Schema:
			t = "[]" + g.getGoType(goType, name, s.Elem.(*schema.Schema))
		default:
			panic(fmt.Sprintf("Unsupported TypeList: %v", s.Elem))
		}
	case schema.TypeMap:
		t = "map[string]string"
	case schema.TypeSet:
		switch s.Elem.(type) {
		case *schema.Resource:
			t = g.deriveGoType(goType, name)
			g.generateResourceType(t, s.Elem.(*schema.Resource), false)
			t = "[]" + t
		case *schema.Schema:
			t = "[]" + g.getGoType(goType, name, s.Elem.(*schema.Schema))
		default:
			panic(fmt.Sprintf("Unsupported TypeSet: %v", s.Elem))
		}
	default:
		panic(fmt.Sprintf("Unknown schema type: %v", s.Type))
	}
	return t
}

func (g *generator) getGoTypeWithPtr(goType, name string, s *schema.Schema) string {
	t := g.getGoType(goType, name, s)
	if !s.Required {
		t = "*" + t
	}
	return t
}

func (g *generator) generatePrefix(prefixTemplateData prefixData) {
	tmpl := template.Must(template.New("prefixTemplate").Parse(prefixTemplate))
	err := tmpl.Execute(g.code, prefixTemplateData)
	if err != nil {
		panic(err)
	}
}

func (g *generator) generateResourceType(nativeType string, r *schema.Resource, insertID bool) ([]string, []string) {

	// Sort field names to give predictable code generation
	names := make([]string, 0, len(r.Schema))
	for name := range r.Schema {
		names = append(names, name)
	}
	sort.Strings(names)

	// Check for provided and immutable attributes
	var providedAttributes []string
	var immutableAttributes []string
	for _, name := range names {
		s := r.Schema[name]
		if s.ForceNew {
			immutableAttributes = append(immutableAttributes, name)
		}
		if s.Computed {
			// TODO: This looks rather odd. Why do we assume that a non-required attribute is provided?
			providedAttributes = append(providedAttributes, name)
		}
	}

	// Determine field names and types
	structType := strings.Title(nativeType)
	structFields := make([]structField, len(names))
	for i, name := range names {
		structFields[i] = structField{
			FieldName: strings.Title(name),
			FieldType: g.getGoTypeWithPtr(structType, name, r.Schema[name]),
		}
	}

	// Build template data
	templateData := structData{
		StructType:   structType,
		StructFields: structFields,
		InsertID:     insertID,
	}

	// Render template
	tmpl := template.Must(template.New("typeTemplate").Parse(typeTemplate))
	err := tmpl.Execute(g.code, templateData)
	if err != nil {
		panic(err)
	}
	return providedAttributes, immutableAttributes
}

func (g *generator) generateResource(nativeType string, r *schema.Resource, types []providerData) []providerData {
	providedAttributes, immutableAttributes := g.generateResourceType(nativeType, r, true)

	return append(types, providerData{
		StructType:          strings.Title(nativeType),
		NativeType:          nativeType,
		ProvidedAttributes:  providedAttributes,
		ImmutableAttributes: immutableAttributes,
	})
}

// formatCode reformats the code as `go fmt` would
func (g *generator) formatCode() []byte {
	code := g.code.Bytes()
	src, err := format.Source(code)
	if err != nil {
		panic(fmt.Errorf("unexpected error running format.Source: %s", err.Error()))
	}
	return src
}

func writeSourceFile(filename string, source... []byte) {
	mkdirs(filename)
	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	for _, s := range source {
		_, err = f.Write(s)
		if err != nil {
			panic(err)
		}
	}
}

// Generate the Lyra boilerplate needed to bridge to a Terraform provider
func Generate(p *schema.Provider, ns, filename string) {

	// Reset
	g := &generator{saltValue:0, code: bytes.NewBufferString(``)}

	// Sort native types to give predictable output
	nativeTypes := make([]string, 0)
	for nativeType := range p.ResourcesMap {
		nativeTypes = append(nativeTypes, nativeType)
	}
	sort.Strings(nativeTypes)

	// Generate code
	types := make([]providerData, 0, len(nativeTypes))
	for _, nativeType := range nativeTypes {
		r := p.ResourcesMap[nativeType]
		types = g.generateResource(nativeType, r, types)
	}
	body := g.formatCode()
	g.code.Reset()
	g.generatePrefix(prefixData{Namespace: ns, StructTypes: types})

	// Write source
	writeSourceFile(filename, g.formatCode(), body)
}
